package admin_account

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/cryptogateway/backend-envoys/assets/common/query"
	"github.com/cryptogateway/backend-envoys/server/proto/v1/admin.pbaccount"
	"github.com/cryptogateway/backend-envoys/server/types"
	"google.golang.org/grpc/status"
	"strings"
)

// GetAccounts - This function is used to retrieve a list of users accounts from a database and the associated rules associated with
// each user. It takes the context.Context, req *admin_pbaccount.GetRequestUsers as parameters and returns the response of
// type admin_pbaccount.ResponseUser and an error. It also performs various operations such as authentication and querying the
// database to retrieve the required information.
func (a *Service) GetAccounts(ctx context.Context, req *admin_pbaccount.GetRequestUsers) (*admin_pbaccount.ResponseUser, error) {

	// The purpose of the above code is to declare a number of variables for use within the program. Var response is of type
	// admin_pbaccount.ResponseUser, and var migrate is of type query.Migrate. Var maps is an empty slice of strings, and var
	// rules is an empty slice of bytes. All of these variables are declared for use within the program.
	var (
		response admin_pbaccount.ResponseUser
		migrate  = query.Migrate{
			Context: a.Context,
		}
		maps  []string
		rules []byte
	)

	// This code is authenticating a user for a specific context. The 'a.Context.Auth(ctx)' function returns the user's
	// authentication details and the return an error if the authentication fails. The
	// purpose of this code is to ensure that the user is authenticated before proceeding with the requested action.
	auth, err := a.Context.Auth(ctx)
	if err != nil {
		return &response, err
	}

	// This code is checking to see if the user has the necessary permissions to write and edit data. If they do not, an
	// error is returned. To migrate.Rules() function is used to check if the user has the necessary rights to perform the
	// action. The parameters passed to the function specify the authentication type, the type of data they are trying to
	// access, and the role they must have in order to perform the action.
	if !migrate.Rules(auth, "accounts", query.RoleDefault) {
		return &response, status.Error(12011, "you do not have rules for writing and editing data")
	}

	// This code is checking the length of a request's search query. If the request has a search query, the code appends a
	// SQL WHERE clause to the maps variable to search for matches in the database. The %[1]s is a placeholder for the
	// search query.
	if len(req.GetSearch()) > 0 {
		maps = append(maps, fmt.Sprintf("where name like %[1]s or email like %[1]s", "'%"+req.GetSearch()+"%'"))
	}

	// This code is used to query a database and store the result of the query in the response.Count variable. The query is
	// configured using a SQL query string that is generated by concatenating the maps variable with a " " string. The Scan
	// function is used to store the result of the query in the response.Count variable.
	if _ = a.Context.Db.QueryRow(fmt.Sprintf("select count(*) as count from accounts %s", strings.Join(maps, " "))).Scan(&response.Count); response.GetCount() > 0 {

		// This code is calculating an offset for a page of results. The page and limit of the results are being requested by
		// the req object. The offset is calculated by multiplying the limit by the page. If the page is greater than 0, then
		// the offset is calculated by multiplying the limit by the page minus 1. This is to account for the fact that the
		// first page of results should start at 0.
		offset := req.GetLimit() * req.GetPage()
		if req.GetPage() > 0 {
			offset = req.GetLimit() * (req.GetPage() - 1)
		}

		// This code is performing a SQL query on a database. The purpose of the query is to select specific columns from the
		// accounts table and order the results by id in descending order, limited to a given number of results. The
		// strings.Join and fmt.Sprintf functions are used to produce a valid SQL query string. The rows variable is used to
		// store the results of the query in a row iterator. To defer rows.Close() statement is used to ensure that the row
		// iterator is closed after the query has been completed.
		rows, err := a.Context.Db.Query(fmt.Sprintf("select id, name, email, status, create_at, rules from accounts %s order by id desc limit %d offset %d", strings.Join(maps, " "), req.GetLimit(), offset))
		if err != nil {
			return &response, err
		}
		defer rows.Close()

		// The for rows.Next() statement is used to iterate through a set of rows in a database query result. It is typically
		// used in conjunction with a database query to loop through the result set, performing some action on each row.
		for rows.Next() {

			// The purpose of the above code is to declare two variables, item and counts, which are both of type types.User
			// and types.Counts respectively. These variables can then be used to store values of the given types.
			var (
				item   types.User
				counts types.Counts
			)

			// This code is used to retrieve data from a database table and store it in a struct. The Scan function takes the
			// values from the retrieved row and assigns them to the variables that have been passed in. The err variable is used
			// to check if any errors occur while retrieving the data. If there is an error, the  return an error response.
			if err = rows.Scan(
				&item.Id,
				&item.Name,
				&item.Email,
				&item.Status,
				&item.CreateAt,
				&rules,
			); err != nil {
				return &response, err
			}

			// The purpose of this code is to retrieve the secret from the KYC (Know Your Customer) database, based on a given
			// user ID, and store it in a variable called "item.KycSecret", "item.KycSecure".
			_ = a.Context.Db.QueryRow("select secret, secure from kyc where user_id = $1", item.Id).Scan(&item.KycSecret, &item.KycSecure)

			// This code is used to convert a JSON-formatted byte slice into a Go data structure. The json.Unmarshal function
			// takes two arguments: the byte slice (rules) and a reference to a Go data structure (item.Rules). If an error occurs
			// during the operation, an error is returned and handled with the a.Context.Error function.
			if err := json.Unmarshal(rules, &item.Rules); err != nil {
				return &response, err
			}

			// The purpose of this code is to query a database for the number of transactions, orders, and assets associated with
			// a given user ID. The code then uses the Scan() function to store the results of the queries in the 'counts' struct.
			// The leading underscore is used to suppress the compiler warning about not using the return value of the QueryRow() function.
			_ = a.Context.Db.QueryRow("select count(*) as count from transactions where user_id = $1", item.Id).Scan(&counts.Transaction)
			_ = a.Context.Db.QueryRow("select count(*) as count from orders where user_id = $1", item.Id).Scan(&counts.Order)
			_ = a.Context.Db.QueryRow("select count(*) as count from balances where user_id = $1", item.Id).Scan(&counts.Asset)

			// The purpose of this statement is to assign the address of the variable 'counts' to the 'Counts' item. This allows
			// the 'Counts' item to refer to the same memory location as the 'counts' variable.
			item.Counts = &counts

			// This is used to add an item to the response.Fields slice. The append function is used to add a single element to
			// the end of the slice. The &item parameter is the item to add to the slice.
			response.Fields = append(response.Fields, &item)
		}

		// The purpose of this code is to check for an error after running a query on a database. If the query returns an
		// error, it will return the response and an error message. This is useful for handling errors that may occur while
		// executing a query.
		if err = rows.Err(); err != nil {
			return &response, err
		}
	}

	return &response, nil
}

// GetAccount - This function is used to get a user's account rule from the database. It takes the context and a GetRequestUserRule as
// parameters, and returns a ResponseUser and an error. It first checks the user's authentication, then checks the user's
// rules, and if they exist, queries the database for the user's information and rules. The rules are then unmarshaled
// and added to the response. Finally, the response is returned.
func (a *Service) GetAccount(ctx context.Context, req *admin_pbaccount.GetRequestUser) (*admin_pbaccount.ResponseUser, error) {

	// The code above is declaring variables that will be used in a program. The variables are of type
	// 'admin_pbaccount.ResponseUser', 'types.User', 'query.Migrate' and 'byte'. The variable 'response' is used to store the
	// response from a user, the variable 'user' is used to store a user object, the variable 'migrate' is used to store
	// migration rules, and the variable 'rules' is used to store the data in binary format.
	var (
		response admin_pbaccount.ResponseUser
		user     types.User
		migrate  = query.Migrate{
			Context: a.Context,
		}
		rules []byte
	)

	// The purpose of the code snippet is to authenticate a user. The variable "a" is assumed to be an instance of an
	// application. The function "Context.Auth" is called to authenticate the user with the given context "ctx". If an error
	// occurs, then the function "Context.Error" is called to return an appropriate error.
	auth, err := a.Context.Auth(ctx)
	if err != nil {
		return &response, err
	}

	// This code is checking if the user has the necessary permissions to modify the data in the accounts table. If the user
	// does not have the appropriate rules, the code returns an error message.
	if !migrate.Rules(auth, "accounts", query.RoleDefault) {
		return &response, status.Error(12011, "you do not have rules for writing and editing data")
	}

	// This code is attempting to query a database for a user's account information based on their ID. The query will return
	// the user's id, name, email, status, and rules and store them in the variables passed to the Scan() function. If the
	// query fails, an error is returned.
	if err := a.Context.Db.QueryRow("select id, name, email, status, rules from accounts where id = $1", req.GetId()).Scan(&user.Id, &user.Name, &user.Email, &user.Status, &rules); err != nil {
		return &response, err
	}

	// This code is part of a function that is attempting to unmarshal a JSON object into a user's Rules field. The purpose
	// of the if statement is to check if the unmarshaling was successful. If it was not successful, the function will
	// return an error.
	if err := json.Unmarshal(rules, &user.Rules); err != nil {
		return &response, err
	}

	// This statement is used to append the value of the user variable to the Fields array of the response object. The
	// purpose of this statement is to add the user object to the response object.
	response.Fields = append(response.Fields, &user)

	return &response, nil
}

// SetAccount - This function is used to set the account rule of a user in the database. It takes in the request object containing the
// user details and context object. First, it authenticates the user and then checks if they have the rules for writing
// and editing data. If they do, it serializes the user's rules, updates the database and returns the response object.
func (a *Service) SetAccount(ctx context.Context, req *admin_pbaccount.SetRequestUser) (*admin_pbaccount.ResponseUser, error) {

	// The purpose of this code is to create two variables, response and migrate. The response variable is of type
	// admin_pbaccount.ResponseUser, and the migrate variable is of type query.Migrate with a context field set to the value of
	// the a.Context variable.
	var (
		response admin_pbaccount.ResponseUser
		migrate  = query.Migrate{
			Context: a.Context,
		}
	)

	// This code snippet is used to authenticate a user in a given context. It assigns the authentication details to the
	// variable auth, and if an error is encountered, it returns an error response and the corresponding error.
	auth, err := a.Context.Auth(ctx)
	if err != nil {
		return &response, err
	}

	// This code is checking if a user has the correct permissions to write and edit data. If they do not have the correct
	// permissions, an error is returned with the message "you do not have rules for writing and editing data".
	if !migrate.Rules(auth, "accounts", query.RoleDefault) || migrate.Rules(auth, "deny-record", query.RoleDefault) {
		return &response, status.Error(12011, "you do not have rules for writing and editing data")
	}

	// This code is used to convert a given object into a JSON string (serialize), so it can be transferred over a network
	// or written to a file. The Marshal function is part of the json package, and it takes a given object
	// (req.User.GetRules()) as an argument. If an error occurs during the serializing process, the error is returned and the function exits.
	serialize, err := json.Marshal(req.User.GetRules())
	if err != nil {
		return &response, err
	}

	// This code is executing an update query to the "accounts" table in the database. The purpose of this code is to update
	// the name, status, and rules of an account in the database by its ID. The parameters of the query are passed in as
	// variables. If there is an error with executing the query, an error is returned.
	if _, err := a.Context.Db.Exec("update accounts set name = $1, status = $2, rules = $3 where id = $4;",
		req.User.GetName(),
		req.User.GetStatus(),
		serialize,
		req.GetId(),
	); err != nil {
		return &response, err
	}

	return &response, nil
}
